// 计数排序
// 计数排序是一个非基于比较的排序算法，该算法于1954年由 Harold H. Seward 提出。
// 它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。
// 当然这是一种牺牲空间换取时间的做法，而且当O(k)>O(n*log(n))的时候其效率反而不如基于比较的排序
// （基于比较的排序的时间复杂度在理论上的下限是O(n*log(n)), 如归并排序，堆排序）
// 算法思想
// 计数排序对输入的数据有附加的限制条件：
// 1、输入的线性表的元素属于有限偏序集S；
// 2、设输入的线性表的长度为n，|S|=k（表示集合S中元素的总数目为k），则k=O(n)。
// 在这两个条件下，计数排序的复杂性为O(n)。
// 计数排序的基本思想是对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数
// （此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。
// 一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。
// 例如，如果输入序列中只有17个元素的值小于x的值，则x可以直接存放在输出序列的第18个位置上。
// 当然，如果有多个元素具有相同的值时，我们不能将这些元素放在输出序列的同一个位置上，因此，上述方案还要作适当的修改。
// 上面的解释我自己都看不下去，我写一下我自己的理解吧
// 通俗的讲就是找到数组arr中最大的数，把它当做新数组arr1的最大的下标。
// 然后一次遍历，把数组arr中所有的数都对应到arr1的下标，而arr1下标对应的值就是下标在arr中出现的次数
// 我们这样表示arr = [5, 7, 4, 7, 8, 2, 1, 3], arr1[0, 1, 1, 1, 1, 1, 0, 2, 1]
// arr1表示为0个0, 1 个1, 1 个2， 1 个3， 1 个4, 1 个5, 0 个6, 2 个7, 1 个8
// 然后再新建一个数组，长度和arr相同，一次把arr1下标代表次数的数，填入到新数组中去

// 那么要实现一个计数排序，又拢共需要几步呢
// 第一步，新建两个数组，res和 list,res用来放返回值，list用来计数
// 第二步，找到原数组arr中最大的数，表示list的最大下标,我的理解是为了后面循环用,不然我完全可以直接往里面填啊,这里我没想明白
// 第三步,循环原数组,填入list
// 第四步，根据list和arr，填入res

function countSort(arr) {
  let len = arr.length;
  let res = [];
  let list = [];
  let max = 0;

  for (let i = 0; i < len; i++) {
    if (arr[i] > max) max = arr[i]
  }
  for (let i = 0; i < len; i++) {
    list[arr[i]] = list[arr[i]] ? list[arr[i]] + 1 : 1
  }
  for (let i = 0; i < list.length; i++) {
    while (list[i] > 0) {
      res.push(i);
      list[i]--
    }
  }
  console.log(res);
}

// let arr = [4, 4, 6, 3, 6, 7, 2, 3, 1, 1, 1];
let arr = [2, 3, 8, 7, 1, 2, 2, 8, 9]
countSort(arr)