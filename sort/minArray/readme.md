把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。

给你一个可能存在 **重复** 元素值的数组 `numbers` ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 `[3,4,5,1,2]` 为 `[1,2,3,4,5]` 的一次旋转，该数组的最小值为1。

**示例 1：**

```
输入：[3,4,5,1,2]
输出：1
```

**示例 2：**

```
输入：[2,2,2,0,1]
输出：0
```

---

**二分查找**

我们考虑**数组中的最后一个元素** $x$：在最小值右侧的元素，它们的值一定都小于等于 $x$；而在最小值左侧的元素，它们的值一定都大于等于 $x$。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值。

在二分查找的每一步中，左边界为 $low$，右边界为 $high$，区间的中点为 $pivot$，最小值就在该区间内。我们将中轴元素 $numbers[pivot]$ 与右边界元素 $numbers[high]$ 进行比较，可能会有以下的三种情况：

第一种情况是 $numbers[pivot]<numbers[high]$。说明 $numbers[pivot]$ 是最小值右侧的元素，因此我们可以忽略二分查找区间的右半部分。

第二种情况是 $numbers[pivot]>numbers[high]$。说明 $numbers[pivot]$ 是最小值左侧的元素，因此我们可以忽略二分查找区间的左半部分。

第三种情况是 $numbers[pivot]==numbers[high]$。由于重复元素的存在，我们并不能确定 $numbers[pivot]$ 究竟在最小值的左侧还是右侧，因此我们不能莽撞地忽略某一部分的元素。我们唯一可以知道的是，由于它们的值相同，所以无论 $numbers[high]$ 是不是最小值，都有一个它的「替代品」$numbers[pivot]$，因此我们可以忽略二分查找区间的右端点。

当二分查找结束时，我们就得到了最小值所在的位置。

```jsx
var minArray = function(numbers) {
    let low = 0;
    let high = numbers.length - 1;
    while (low < high) {
        const pivot = low + Math.floor((high - low) / 2);
        if (numbers[pivot] < numbers[high]) {
            high = pivot;
        } else if (numbers[pivot] > numbers[high]) {
            low = pivot + 1;
        } else {
            high -= 1;
        }
    }
    return numbers[low];
};
```

**复杂度分析**

- 时间复杂度：平均时间复杂度为 $O(log⁡n)$，其中 $n$ 是数组 $numbers$ 的长度。如果数组是随机生成的，那么数组中包含相同元素的概率很低，在二分查找的过程中，大部分情况都会忽略一半的区间。而在最坏情况下，如果数组中的元素完全相同，那么 $while$ 循环就需要执行 $n$ 次，每次忽略区间的右端点，时间复杂度为 $O(n)$。
- 空间复杂度：$O(1)$。